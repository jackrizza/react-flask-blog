{"ast":null,"code":"/*eslint no-console: 0*/\nvar React = require('react');\n\nvar showdown = require('showdown');\n\nvar htmlparser = require('htmlparser2');\n/**\n * Example: new Converter(options).convert(markdown)\n *\n * Options will be pushed forward to the showdown converter:\n * https://github.com/showdownjs/showdown#valid-options\n * Just the `components` option is managed by this converter.\n * It define the component name (tag name) to component React class definition\n * (instance of createClass) mapping.\n */\n\n\nmodule.exports = function Converter(options) {\n  'use strict';\n\n  var self = this;\n  this._converter = new showdown.Converter(options); // remove newlines from table tags\n\n  this._converter.listen('tables.after', function (_, text) {\n    var result = text;\n    var tags = ['table', 'thead', 'tbody', 'tfoot', 'th', 'tr', 'td'];\n    tags.forEach(function (tag) {\n      result = result.replace(new RegExp('\\n<' + tag, 'g'), '<' + tag).replace(new RegExp('\\n</' + tag, 'g'), '</' + tag);\n    });\n    return result;\n  });\n\n  this._components = Object.assign({}, options && options.components);\n\n  function fixClass(element) {\n    if (!element.attribs.class) {\n      return;\n    }\n\n    element.attribs.className = element.attribs.class;\n    delete element.attribs.class;\n  } // remove the style attribute and apply it after component mount\n\n\n  function fixStyle(element) {\n    if (!element.attribs.style) {\n      return;\n    }\n\n    var style = element.attribs.style;\n    delete element.attribs.style;\n\n    element.attribs.ref = function (c) {\n      if (c) {\n        c.setAttribute('style', style);\n      }\n    };\n  }\n\n  this._mapElement = function (element) {\n    if (element.type === 'tag') {\n      fixStyle(element);\n      fixClass(element); // this is used to let showdown know whether or not to render md inside of\n      // an html element - we want to strip this out before we go to react to\n      // avoid unknown prop warnings\n\n      delete element.attribs.markdown;\n      var component = this._components[element.name] || element.name;\n      return React.createElement(component, element.attribs, this._mapElements(element.children));\n    } else if (element.type === 'text') {\n      return element.data;\n    } else if (element.type === 'comment') {\n      // noop\n      return null;\n    } else {\n      console.warn('Warning: Could not map element with type ' + element.type + ' yet.');\n      return null;\n    }\n  };\n\n  this._mapElements = function (elements) {\n    var children = React.Children.toArray(elements.map(function (element) {\n      return self._mapElement(element);\n    }).filter(function (element) {\n      return element;\n    }));\n    return children.length === 0 ? null : children;\n  };\n\n  var parserOptions = {\n    // make sure to decode entities to avoid security issue, see\n    // https://github.com/fb55/htmlparser2/issues/105\n    decodeEntities: true,\n    // keep case of attribute names so that stuff like `className` works correctly\n    lowerCaseAttributeNames: false,\n    // don't alter the case of tags\n    lowerCaseTags: false\n  };\n\n  this.convert = function (markdown) {\n    var html = this._converter.makeHtml(markdown);\n\n    var root = htmlparser.parseDOM(html, parserOptions);\n\n    var reactElements = this._mapElements(root);\n\n    if (reactElements && reactElements.length === 1) {\n      return reactElements[0];\n    } else {\n      return React.createElement('div', null, reactElements);\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}